/* File generated with Shader Minifier 1.3.1
 * http://www.ctrl-alt-test.fr
 */

// E:\CppDev\GradDemo\Haru86_GraphicsEngine\Assets\App\GradDemo\3_MoonTravel\Shader\MoonTravel_Frag.h
"#version 330\n"
 "uniform float _time;"
 "uniform vec2 _resolution;"
 "uniform float _RenderingTarget;"
 "uniform vec3 _WorldCameraPos,_WorldCameraCenter;"
 "uniform float _ShowStartTime,_ShowTimeDuration,_Alpha,_MoveSpeed;"
 "uniform int _DrawEarth;"
 "in vec2 uv;\n"
 "#define pi 3.14159265\n"
 "#define rot(a)mat2(cos(a),-sin(a),sin(a),cos(a))\n"
 "#define dmin 0.001\n"
 "#define tmax 30.0\n"
 "#define ldir normalize(vec3(0.0,1.0,-1.0))\n"
 "vec3 d;"
 "int v;"
 "float f;struct mapr{float d;bool hit;int m;float tvalue;float i;float acc;};"
 "void r(inout mapr v,float e,int f,bool m)"
 "{"
   "if(m)"
     "{"
       "if(e<v.d)"
         "v=mapr(e,false,f,0.,0.,0.);"
       "if(v.d<dmin)"
         "v.hit=true;"
     "}"
   "else"
     "{"
       "if(e>v.d)"
         "v=mapr(e,false,f,0.,0.,0.);"
       "if(v.d<dmin)"
         "v.hit=true;"
     "}"
 "}"
 "vec3 t(vec3 v,vec3 m,vec3 e,vec3 x)"
 "{"
   "return v+=x,v.yz*=rot(m.x),v.xz*=rot(m.y),v.xy*=rot(m.z),v*=m,v;"
 "}"
 "float r(vec2 v)"
 "{"
   "return fract(sin(dot(v.xy,vec2(12.9898,78.233)))*43758.5453123);"
 "}\n"
 "#define Moon_FREQ 0.16\n"
 "#define Moon_HEIGHT 0.6\n"
 "#define Moon_CHOPPY 4.8\n"
 "#define ITER_GEOMETRY 3\n"
 "#define ITER_FRAGMENT 3\n"
 "#define Moon_SPEED 0.8\n"
 "#define Moon_TIME (1.0+_time*Moon_SPEED)\n"
 "#define NUM_STEPS 8\n"
 "#define EPSILON_NRM (0.1/_resolution.x)\n"
 "#define Moon_BASE vec3(0.1,0.19,0.22)\n"
 "#define Moon_WATER_COLOR vec3(0.8,0.9,0.6)\n"
 "float t(vec2 v)"
 "{"
   "return fract(sin(dot(v.xy,vec2(12.9898,78.233)))*43758.5453123);"
 "}"
 "float m(vec2 v)"
 "{"
   "vec2 m=floor(v),x=fract(v);"
   "float e=t(m+vec2(0.,0.)),f=t(m+vec2(1.,0.)),s=t(m+vec2(0.,1.)),d=t(m+vec2(1.,1.));"
   "vec2 a=x*x*(3.-2.*x);"
   "return mix(e,f,a.x)+(s-e)*a.y*(1.-a.x)+(d-f)*a.x*a.y;"
 "}"
 "float m(vec2 v,float f)"
 "{"
   "v+=m(v);"
   "vec2 e=1.-abs(sin(v)),d=abs(cos(v));"
   "e=mix(e,d,e);"
   "return pow(1.-pow(e.x*e.y,.65),f);"
 "}"
 "mapr x(vec3 v)"
 "{"
   "v.y+=.5;"
   "mapr e=mapr(1e3,false,-1,0.,0.,0.);"
   "float f=Moon_FREQ,d=Moon_HEIGHT,x=Moon_CHOPPY;"
   "vec2 s=v.xz;"
   "float a,z=0.;"
   "mat2 M=mat2(1.6,1.2,-1.2,1.6);"
   "for(int i=0;i<ITER_GEOMETRY;i++)"
     "a=m(s*f,x),a+=m(s*f,x),z+=a*d,s*=M,f*=2.,d*=.2,x=mix(x,1.,.2);"
   "r(e,v.y-z,1,true);"
   "return e;"
 "}"
 "mapr n(vec3 v)"
 "{"
   "v.y+=.5;"
   "mapr e=mapr(1e3,false,-1,0.,0.,0.);"
   "float f=Moon_FREQ,x=Moon_HEIGHT,d=Moon_CHOPPY;"
   "vec2 s=v.xz;"
   "float a,z=0.;"
   "mat2 M=mat2(1.6,1.2,-1.2,1.6);"
   "for(int i=0;i<ITER_FRAGMENT;i++)"
     "a=m(s*f,d),a+=m(s*f,d),z+=a*x,s*=M,f*=2.,x*=.2,d=mix(d,1.,.2);"
   "r(e,v.y-z,1,true);"
   "return e;"
 "}"
 "mapr n(vec3 v,vec3 e)"
 "{"
   "v.z+=_time*_MoveSpeed;"
   "float m=0.,f=1e3,d=x(v+e*f).d;"
   "mapr a=mapr(1e3,false,-1,0.,0.,0.);"
   "float i=0.,r=0.;"
   "if(d>0.)"
     "return a.hit=false,a;"
   "float s=x(v+e*m).d,z=0.;"
   "for(i=0.;i<float(NUM_STEPS);i++)"
     "{"
       "float t=s/(s-d);"
       "z=mix(m,f,t);"
       "vec3 M=v+e*z;"
       "a=x(M);"
       "r+=exp(-3.*a.d);"
       "float n=a.d;"
       "if(n<0.)"
         "f=z,d=n;"
       "else"
         " m=z,s=n;"
     "}"
   "a.i=i;"
   "a.tvalue=z;"
   "a.acc=r;"
   "a.hit=true;"
   "return a;"
 "}"
 "float s(float v)"
 "{"
   "return fract(sin(v)*753.5453123);"
 "}"
 "float p(vec3 v)"
 "{"
   "vec3 m=floor(v),f=fract(v);"
   "f=f*f*(3.-2.*f);"
   "float e=m.x+m.y*157.+113.*m.z;"
   "return mix(mix(mix(s(e),s(e+1.),f.x),mix(s(e+157.),s(e+158.),f.x),f.y),mix(mix(s(e+113.),s(e+114.),f.x),mix(s(e+270.),s(e+271.),f.x),f.y),f.z);"
 "}"
 "vec4 M(vec4 v)"
 "{"
   "return v.xz=abs(v.xz+1.)-abs(v.xz-1.)-v.xz,v=v*2./clamp(dot(v.xyz,v.xyz),.15,1.)-vec4(.5,.5,.8,0.),v.xy*=rot(.5),v;"
 "}"
 "float M(vec3 v,float e,float f)"
 "{"
   "float i=0.,d=0.;"
   "for(float m=0.;m<e;m++)"
     "{"
       "float a=pow(.5,m+1.)*f;"
       "i+=a*p(v);"
       "v=2.*v;"
       "d+=a;"
     "}"
   "return i/d;"
 "}"
 "mapr a(vec3 v)"
 "{"
   "mapr e=mapr(1e3,false,-1,0.,0.,0.);"
   "if(_time<_ShowStartTime)"
     "r(e,length(t(v,vec3(1.),vec3(0.),vec3(0.,-2.,0.)))-1.25,1,true);"
   "else"
     "{"
       "v.z+=_time*_MoveSpeed;"
       "vec4 f=vec4(v,1.5);"
       "f.x=-abs(f.x);"
       "f.x=mod(f.x,2.)-1.;"
       "f.x+=1.;"
       "if(_time>=_ShowStartTime&&_time<_ShowStartTime+_ShowTimeDuration)"
         "{"
           "float m=8.;"
           "f.y+=m-m*(_time-_ShowStartTime)/_ShowTimeDuration;"
         "}"
       "f.y+=-1.5;"
       "f.z=abs(2.-mod(f.z,4.));"
       "for(int i=0;i<8;i++)"
         "f=M(f);"
       "float d=length(max(vec2(0.),f.yz-3.))/f.w;"
       "r(e,d,0,true);"
     "}"
   "return e;"
 "}"
 "vec3 e(vec3 v)"
 "{"
   "vec2 f=vec2(.001,0.);"
   "return normalize(vec3(a(v+f.xyy).d-a(v-f.xyy).d,a(v+f.yxy).d-a(v-f.yxy).d,a(v+f.yyx).d-a(v-f.yyx).d));"
 "}"
 "vec3 M(vec3 v,float e)"
 "{"
   "vec3 f;"
   "f.y=n(v).d;"
   "f.x=n(vec3(v.x+e,v.y,v.z)).d-f.y;"
   "f.z=n(vec3(v.x,v.y,v.z+e)).d-f.y;"
   "f.y=e;"
   "return normalize(f);"
 "}"
 "mapr a(vec3 v,vec3 e,const bool f)"
 "{"
   "mapr m;"
   "float d=0.,s=0.,i=0.;"
   "for(;++d<150.;)"
     "{"
       "m=a(v+e*(s+=m.d*.5));"
       "if(m.d<dmin||m.tvalue>tmax)"
         "break;"
       "i+=exp(-3.*m.d);"
     "}"
   "m.i=d;"
   "m.tvalue=s;"
   "m.acc=i;"
   "return m;"
 "}"
 "float a(vec3 v,vec3 e)"
 "{"
   "float f=1.,d=dmin;"
   "for(int i=0;i<32;i++)"
     "{"
       "float m=a(v+e*d).d;"
       "if(f<1e-4||d>tmax)"
         "break;"
       "f=min(f,max(0.,10.*m/d));"
       "d+=m;"
     "}"
   "f=clamp(f,0.,1.);"
   "return f;"
 "}"
 "float e(const vec3 e,const vec3 v)"
 "{"
   "float m=.0016,f=0.,d=13.;"
   "for(int i=0;i<5;i++)"
     "{"
       "float x=m*float(i*i);"
       "vec3 s=v*x+e;"
       "float M=a(s).d;"
       "f+=-(M-x)*d;"
       "d*=.7;"
     "}"
   "return clamp(1.-5.*f,0.,1.);"
 "}"
 "float p(vec3 v,vec3 e)"
 "{"
   "float f=1.,i=0.;"
   "for(int m=0;m<5;m++)"
     "{"
       "float d=.15+float(m)*.15,x=a(e*d+v).d;"
       "i+=(d-x)*f;"
       "f*=.5;"
     "}"
   "return clamp(1.-i,0.,1.);"
 "}\n"
 "#define tile 0.850\n"
 "vec3 r(vec3 v,vec3 e)"
 "{"
   "if(_time>=_ShowStartTime)"
     "v.z+=_time*_MoveSpeed*.05;"
   "else"
     " v.z+=_time*_MoveSpeed*.001;"
   "vec3 f=vec3(0.);"
   "float m=.1,d=1.;"
   "v.x+=1.;"
   "for(int i=0;i<20;i++)"
     "{"
       "vec3 x=v+e*m;"
       "float a=0.,r=0.;"
       "x=abs(vec3(tile)-mod(x,vec3(tile*2.)));"
       "for(int z=0;z<17;z++)"
         "{"
           "float M=2.;"
           "x=abs(x)/dot(x,x)*M-.5*M;"
           "r+=abs(length(x)-a);"
           "a=length(x);"
         "}"
       "r*=r*r;"
       "f+=vec3(m,m*m,m*m*m*m)*r*.0015*d;"
       "d*=.73;"
       "m+=.1;"
     "}"
   "return f*.01;"
 "}"
 "vec3 M(mapr v,mapr f,vec3 m,vec3 d,vec2 x)"
 "{"
   "vec3 i=vec3(0.);"
   "if(v.tvalue<10.&&v.m==0)"
     "{"
       "vec3 s=m+d*v.tvalue,z=e(s);"
       "{"
         "float t=a(s,ldir),y=max(0.,dot(ldir,z))*t,n=pow(max(0.,dot(d,-reflect(ldir,z))),15.),c=e(s,z);"
         "i=c*vec3(1.,.8,.6)*y+vec3(1.,.8,.6)*n;"
         "vec3 l=r(s,reflect(d,z));"
         "i=mix(i,l,.2);"
       "}"
     "}"
   "else"
     " if(!f.hit&&v.hit&&v.m==1&&_DrawEarth==1)"
       "{"
         "vec3 s=m+d*v.tvalue,z=e(s);"
         "const mat3 t=mat3(0.,.8,.6,-.8,.36,-.48,-.6,-.48,.64);"
         "vec3 y=s;"
         "y=t*y*2.01;"
         "{"
           "float c=M(2.*y+vec3(160.,40.,120.),6.,1.);"
           "c=pow(c,1.5);"
           "float n=min(4.*max(c-.3,0.),1.);"
           "vec3 l=vec3(1.,1.3,.5);"
           "float h=M(5.*y+vec3(120.),3.,1.);"
           "vec3 T=vec3(0.,.031,.11);"
           "i=mix(T,h*l,n);"
         "}"
         "{"
           "float c=M(7.5*y+vec3(500)+_time,6.,1.);"
           "c=pow(c,1.5);"
           "float n=min(4.*max(c-.3,0.),1.);"
           "vec3 l=vec3(1.);"
           "float h=M(7.5*y+vec3(500.)+_time,3.,1.);"
           "i=mix(i,h*l,n);"
         "}"
       "}"
     "else"
       " if(f.hit)"
         "{"
           "m.z+=_time*_MoveSpeed;"
           "vec3 s=m+d*f.tvalue,z=s-m,c=M(s,dot(z,z)*EPSILON_NRM);"
           "i=vec3(1.)*max(0.,dot(c,ldir));"
           "float t=p(s,c);"
           "i+=t*vec3(1.)*.1;"
         "}"
       "else"
         " i=r(m,d);"
   "return i;"
 "}"
 "void main()"
 "{"
   "if(_RenderingTarget==2)"
     "gl_FragColor=vec4(vec3(0.),1.);"
   "else"
     "{"
       "vec2 v=uv*2.-1.;"
       "v.x*=_resolution.x/_resolution.y;"
       "vec3 e=_WorldCameraPos,d=_WorldCameraCenter,x=normalize(d-e),m=normalize(cross(vec3(0.,1.,0.),x)),i=normalize(cross(x,m)),z=normalize(v.x*m+v.y*i+x),s=vec3(0.);"
       "f=100.;"
       "mapr c=a(e,z,false),t=n(e,z);"
       "s=M(c,t,e,z,v);"
       "gl_FragColor=vec4(s,_Alpha);"
     "}"
 "}",

